# Copyright 2014-2015 Josh Pieper, jjp@pobox.com.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys

Import('canonenv')
Import('libbase')
env = canonenv.Clone()

env.Append(CPPPATH=['.'])
env.Append(LIBS=['boost_filesystem',
                 'boost_date_time'])

crenv = env.Clone()
crenv.Append(LIBS=['boost_coroutine',
                   'boost_context',
                   ])

gsenv = env.Clone()

# We do not want to use stock gstreamer -- it has hard-to-catch bugs like
# streams stopping after few minutes of operation. We require a custom-built
# one from 'mj-gstreamer-build' project.
gstreamer_root = '/opt/gstreamer-1.4.5'
gs_min_revision = 1
try:
    gs_rev = open(gstreamer_root + '/mj-gstreamer-revision', 'r').read().strip()
except IOError:
    print >>sys.stderr, \
        'ERROR: custom-compiled gstreamer not found. try install_packages.sh'
    sys.exit(1)

if int(gs_rev) < gs_min_revision:
    print >>sys.stderr, 'ERROR: custom-compiled gstreamer has wrong revision'
    print >>sys.stderr, 'try removing %s, then re-run install_packages.sh' \
        % gstreamer_root
    sys.exit(1)


gsenv['GS_LIB'] = gstreamer_root + '/lib'
gsenv['RPATH'] = '$GS_LIB'

for lib in [
        'gstreamer-rtsp-server-1.0', 'gstreamer-rtsp-1.0', 'gstreamer-sdp-1.0',
        'gstreamer-1.0', 'gstreamer-base-1.0', 'gstreamer-app-1.0',
        'glib-2.0', 'gobject-2.0']:
    gsenv.ParseConfig('PKG_CONFIG_PATH=$GS_LIB/pkgconfig pkg-config '
                      '--cflags --libs ' + lib)

SOURCES = [
    'ahrs.cc',
    gsenv.SharedObject('camera_driver.cc'),
    'gait_driver.cc',
    gsenv.SharedObject('gst_main_loop.cc'),
    'herkulex.cc',
    'mech_warfare.cc',
    'mjmech_imu_driver.cc',
    gsenv.SharedObject('rtsp_server.cc'),
    'servo_monitor.cc',
    'turret.cc',
    gsenv.SharedObject('video_display.cc'),
    ]

libmech = env.StaticLibrary('mech', SOURCES)
libmech_so = env.SharedLibrary('mech', SOURCES)

Export('libmech')
Export('libmech_so')

herkulex_tool = crenv.Program('herkulex_tool',
                              ['herkulex_tool.cc'] + libmech + libbase)

TESTS = ['test/' + x for x in [
        'herkulex_test.cc',
        'leg_ik_test.cc',
        'test_main.cc',
        'ripple_test.cc',
        ]]

testenv = crenv.Clone()
testenv.Append(LIBS=['boost_unit_test_framework'])

test_mech = testenv.Program('test_mech', TESTS + libmech + libbase)
testenv.Command('test_mech.passed', test_mech,
                '$SOURCE && touch $TARGET')

mech_warfare_command = crenv.Program(
    'mw_command',
    ['mech_warfare_command.cc'] + libmech + libbase)

def ModuleMain(root, cname, env=None):
    if env is None:
        env = crenv
    mjmech_main = env.Object(
        root + '_main.o', 'module_main.cc',
        CPPDEFINES={'MODULE_HEADER_FILE': '\\"' + root + '.h\\"',
                    'MODULE_CLASS_NAME': cname})
    env.Depends(mjmech_main, root + '.h')
    env.Depends(mjmech_main, libmech)
    env.Depends(mjmech_main, libbase)
    return env.Program(root, mjmech_main + libmech + libbase)

ModuleMain('mjmech_imu_driver', 'MjmechImuDriver')
ModuleMain('mech_warfare', 'MechWarfare')
ModuleMain('servo_monitor_app', 'ServoMonitorApp')
ModuleMain('ahrs_app', 'AhrsApp')

sender = ModuleMain('video_sender_app', 'VideoSenderApp',
                    env=gsenv)
gsenv.Command(
    'video_sender_test.passed', sender,
    '$SOURCE -t camera_driver.stats --max_stats=2 --require_stats_good=1 '
    '--remote_debug.port=0 --camera.device=TEST --rtsp.port=0 && touch $TARGET')

controller = ModuleMain('video_controller_app', 'VideoControllerApp',
                        env=gsenv)
gsenv.Command(
    'video_controller_test.passed', controller,
    '$SOURCE -t video_display.stats --max_stats=2 --require_stats_good=1 '
    '--remote_debug.port=0 --display.source=TEST --display.hide_video=1 '
    ' && touch $TARGET')
